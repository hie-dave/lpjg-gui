using LpjGuess.Core.Interfaces.Factorial;
using LpjGuess.Core.Models.Factorial;
using LpjGuess.Core.Models.Factorial.Generators;
using LpjGuess.Frontend.Classes;
using LpjGuess.Frontend.Delegates;
using LpjGuess.Frontend.DependencyInjection;
using LpjGuess.Frontend.Interfaces.Commands;
using LpjGuess.Frontend.Interfaces.Events;
using LpjGuess.Frontend.Interfaces.Presenters;
using LpjGuess.Frontend.Interfaces.Views;

namespace LpjGuess.Frontend.Presenters;

/// <summary>
/// A presenter for an experiment view.
/// </summary>
public class ExperimentPresenter : PresenterBase<IExperimentView, Experiment>, IExperimentPresenter
{
    /// <summary>
    /// The factorial presenter.
    /// </summary>
    private readonly IFactorialPresenter factorialPresenter;

    /// <summary>
    /// The factory to use for creating presenters.
    /// </summary>
    private readonly IPresenterFactory presenterFactory;

    /// <summary>
    /// The available instruction files in the workspace.
    /// </summary>
    private IInstructionFilesProvider insFilesProvider;

    /// <inheritdoc />
    public Event<string> OnRenamed { get; private init; }

    /// <summary>
    /// Create a new <see cref="ExperimentPresenter"/> instance.
    /// </summary>
    /// <param name="experiment">The experiment to present.</param>
    /// <param name="insFilesProvider">The instruction files provider.</param>
    /// <param name="view">The view to present the experiment on.</param>
    /// <param name="registry">The command registry to use for command execution.</param>
    /// <param name="presenterFactory">The factory to use for creating presenters.</param>
    public ExperimentPresenter(
        Experiment experiment,
        IInstructionFilesProvider insFilesProvider,
        IExperimentView view,
        ICommandRegistry registry,
        IPresenterFactory presenterFactory) : base(view, experiment, registry)
    {
        OnRenamed = new Event<string>();
        this.insFilesProvider = insFilesProvider;
        this.presenterFactory = presenterFactory;
        view.OnChanged.ConnectTo(OnExperimentChanged);
        factorialPresenter = presenterFactory.CreatePresenter<IFactorialPresenter, FactorialGenerator>(GetFactorialGenerator());
        view.SetFactorialView(factorialPresenter.GetView());
        RefreshView();

        factorialPresenter.OnChanged.ConnectTo(OnSimulationGeneratorChanged);
        this.insFilesProvider.OnInstructionFilesChanged.ConnectTo(OnInsFilesChanged);
    }

    /// <inheritdoc />
    public Experiment GetExperiment() => model;

    /// <inheritdoc />
    public override void Dispose()
    {
        insFilesProvider.OnInstructionFilesChanged.DisconnectFrom(OnInsFilesChanged);
        factorialPresenter.Dispose();
        base.Dispose();
    }

    /// <summary>
    /// Refresh the view.
    /// </summary>
    private void RefreshView()
    {
        view.Populate(
            model.Name,
            model.Description,
            model.Runner,
            insFilesProvider.GetInstructionFiles().Select(f => (f, model.InstructionFiles.Contains(f))),
            model.Pfts);
        UpdateSimulations();

        // Do we need to refresh the factorial presenter here? I think not.
    }

    /// <summary>
    /// Update the simulations table displayed in the view.
    /// </summary>
    private void UpdateSimulations()
    {
        view.PopulateSimulations(GetSimulationDescriptions());
    }

    /// <summary>
    /// Generate a description of all simulations generated by the experiment.
    /// </summary>
    /// <returns>A collection of simulation descriptions.</returns>
    private List<SimulationDescription> GetSimulationDescriptions()
    {
        List<SimulationDescription> descriptions = new List<SimulationDescription>();
        IEnumerable<IFactors> simulations = model.SimulationGenerator.Generate();

        foreach (IFactors simulation in simulations)
        {
            List<ParameterChange> changes = new List<ParameterChange>();
            foreach (IFactor factor in simulation.Changes)
            {
                string factorName = factor.GetName();
                foreach ((string paramName, string value) in factor.GetChanges())
                    changes.Add(new ParameterChange(paramName, value, factorName));
            }

            descriptions.Add(new SimulationDescription(simulation.Name, changes));
        }

        return descriptions;
    }

    /// <summary>
    /// Get the factorial generator from the experiment.
    /// </summary>
    /// <returns>The factorial generator.</returns>
    /// <remarks>
    /// This is horrible. Need to rethink if we actually want such a high-level
    /// interface for the generator property, and whether there will actually be
    /// other implementations that we need to support going forward.
    /// </remarks>
    private FactorialGenerator GetFactorialGenerator()
    {
        if (model.SimulationGenerator is not FactorialGenerator generator)
            throw new NotImplementedException($"{model.SimulationGenerator.GetType().Name} is not yet supported.");
        return generator;
    }

    /// <summary>
    /// Invoke the specified command.
    /// </summary>
    /// <param name="command">The command to invoke.</param>
    protected override void InvokeCommand(ICommand command)
    {
        // This will become slightly less trivial once we have a command
        // history.
        string oldName = model.Name;
        base.InvokeCommand(command);
        if (model.Name != oldName)
            OnRenamed.Invoke(model.Name);
        RefreshView();
    }

    /// <summary>
    /// Called when an instruction file is added to or removed from the
    /// workspace.
    /// </summary>
    /// <param name="instructionFiles">The instruction files in the workspace.</param>
    private void OnInsFilesChanged(IEnumerable<string> instructionFiles)
    {
        view.UpdateInstructionFiles(instructionFiles.Select(f => (f, model.InstructionFiles.Contains(f))));
    }

    /// <summary>
    /// Called when the user wants to change the experiment.
    /// </summary>
    /// <param name="change">The change to apply.</param>
    private void OnExperimentChanged(IModelChange<Experiment> change)
    {
        ICommand command = change.ToCommand(model);
        InvokeCommand(command);
    }

    /// <summary>
    /// Called when the simulation generator changes.
    /// </summary>
    private void OnSimulationGeneratorChanged()
    {
        RefreshView();
    }
}
