using System.Data;
using Dave.Benchmarks.Core.Models;
using Dave.Benchmarks.Core.Models.Importer;
using Dave.Benchmarks.Core.Services;
using LpjGuess.Core.Extensions;
using LpjGuess.Core.Models;
using LpjGuess.Frontend.Interfaces.Presenters;
using LpjGuess.Frontend.Interfaces.Views;
using LpjGuess.Frontend.Views;
using LpjGuess.Runner.Models;
using Microsoft.Extensions.Logging;
using InstructionFileParser = LpjGuess.Runner.Parsers.InstructionFileParser;

namespace LpjGuess.Frontend.Presenters;

/// <summary>
/// A presenter which controls an outputs view to display the raw outputs from a
/// model run.
/// </summary>
public class OutputsPresenter : PresenterBase<IOutputsView>, IOutputsPresenter
{
    /// <summary>
    /// Sites with output files written more than this number of seconds before
    /// the most recent write time of any site-level run are considered stale.
    /// </summary>
    private const int staleSiteThresholdSeconds = 300;

    /// <summary>
    /// Output files written more than this number of seconds before the 
    /// newest file are considered stale.
    /// </summary>
    private const double staleFileThresholdSeconds = 5.0;

    /// <summary>
    /// Output file type resolver.
    /// </summary>
    private readonly OutputFileTypeResolver resolver;

    /// <summary>
    /// Output file parser.
    /// </summary>
    private readonly ModelOutputParser outputParser;

    /// <summary>
    /// Instruction file parser.
    /// </summary>
    private readonly Dave.Benchmarks.Core.Services.InstructionFileParser insParser;

    /// <summary>
    /// List of instruction files.
    /// </summary>
    private List<string> instructionFiles;

    /// <summary>
    /// Create a new <see cref="OutputsPresenter"/> instance.
    /// </summary>
    /// <param name="view">The view object.</param>
    public OutputsPresenter(IOutputsView view) : base(view)
    {
        instructionFiles = new List<string>();
        view.OnInstructionFileSelected.ConnectTo(OnInstructionFileSelected);
        view.OnOutputFileSelected.ConnectTo(OnOutputFileSelected);

        // TODO: dependency injection. Don't create an OutputParser every time.
        var factory = new LoggerFactory();
        var logger = new Logger<OutputFileTypeResolver>(factory);
        var logger2 = new Logger<ModelOutputParser>(factory);
        var logger3 = new Logger<Dave.Benchmarks.Core.Services.InstructionFileParser>(factory);

        resolver = new OutputFileTypeResolver(logger);
        outputParser = new ModelOutputParser(logger2, resolver);
        insParser = new Dave.Benchmarks.Core.Services.InstructionFileParser(logger3);
    }

    /// <inheritdoc />
    /// <exception cref="ArgumentException">Thrown if one of the specified instruction files does not specify an output directory.</exception>
    public void Populate(IEnumerable<string> instructionFiles)
    {
        this.instructionFiles = instructionFiles.ToList();

        // Populate the view.
        view.PopulateInstructionFiles(instructionFiles);
    }

    /// <summary>
    /// Get a list of all non-stale output files for the specified instruction
    /// file.
    /// </summary>
    /// <param name="file">An instruction file.</param>
    /// <returns>A list of output files generated by the most recent model run of the given instruction file.</returns>
    private IEnumerable<OutputFile> GetOutputFiles(string file)
    {
        InstructionFileParser parser = InstructionFileParser.FromFile(file);
        InstructionParameter? parameter = parser.GetTopLevelParameter("outputdirectory");
        if (parameter is null)
            throw new ArgumentException($"File '{file}' does not specify an output directory");

        string outputDirectory = parameter.AsString().Trim('"');
        string relativePath = Path.GetDirectoryName(file) ?? Directory.GetCurrentDirectory();
        outputDirectory = Path.GetFullPath(outputDirectory, relativePath);
        IEnumerable<string> outputFiles = Directory.EnumerateFiles(outputDirectory, "*.out");

        DateTime latestWrite = GetMostRecentWriteTime(outputFiles);

        return outputFiles
            .Where(o => !IsStaleFile(o, latestWrite))
            .Select(CreateOutputFile)
            .Where(o => o is not null)
            .Cast<OutputFile>();
    }

    /// <summary>
    /// Create a managed output file object corresponding to the output file at
    /// the specified file path.
    /// </summary>
    /// <param name="filePath">Path to the output file.</param>
    /// <returns>An output file object with metadata.</returns>
    private OutputFile? CreateOutputFile(string filePath)
    {
        try
        {
            // This will throw if unrecognised output files are discovered. This
            // can happen any time new outputs are added to the model without
            // updating OutputFileDefinitions.
            string fileName = Path.GetFileName(filePath);
            string fileType = resolver.GetFileType(fileName);
            OutputFileMetadata metadata = OutputFileDefinitions.GetMetadata(fileType);
            return new OutputFile(metadata, filePath);
        }
        catch (Exception error)
        {
            Console.Error.WriteLine(error);
            return null;
        }
    }

    /// <summary>
    /// Checks if a file is stale by comparing its write time to the most recent write time
    /// </summary>
    /// <param name="filePath">The path to the file.</param>
    /// <param name="mostRecentWriteTime">The most recent write time.</param>
    /// <returns>True if the file is stale, false otherwise.</returns>
    private bool IsStaleFile(string filePath, DateTime mostRecentWriteTime)
    {
        FileInfo fileInfo = new(filePath);
        TimeSpan age = mostRecentWriteTime - fileInfo.LastWriteTime;

        return age.TotalSeconds > staleFileThresholdSeconds;
    }

    /// <summary>
    /// Gets the most recent write time from a set of output files
    /// </summary>
    /// <param name="outputFiles">The files to check.</param>
    /// <returns>The most recent write time.</returns>
    private DateTime GetMostRecentWriteTime(IEnumerable<string> outputFiles)
    {
        return outputFiles
            .Select(f => new FileInfo(f))
            .Max(f => f.LastWriteTime);
    }

    /// <summary>
    /// Called when the user has selected an output file in the output files
    /// dropdown. Populates the data area with the data from the specified
    /// output file.
    /// </summary>
    /// <param name="file">The output file selected by the user.</param>
    private void OnOutputFileSelected(OutputFile file)
    {
        // TODO: true async support.
        Task<Quantity> task = outputParser.ParseOutputFileAsync(file.Path);
        task.Wait();

        Quantity quantity = task.Result;
        DataTable data = quantity.ToDataTable();
        view.PopulateData(data);
    }

    /// <summary>
    /// Called when the user has selected an instruction file in the instruction
    /// files dropdown. Populates the output files dropdown with all available
    /// outputs for the given instruction file.
    /// </summary>
    /// <param name="file">The instruction file selected by the user.</param>
    private void OnInstructionFileSelected(string file)
    {
        // TODO: consolidate instruction file parsers in runner/benchmarks.
        // We are double parsing here (since we also parse when ins files are
        // selected by the user).
        // TODO: true async support
        Task task = insParser.ParseInstructionFileAsync(file);
        task.Wait();
        resolver.BuildLookupTable(insParser);

        IEnumerable<OutputFile> outputs = GetOutputFiles(file);
        view.PopulateOutputFiles(outputs);
    }
}
