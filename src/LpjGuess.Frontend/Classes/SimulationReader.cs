using LpjGuess.Core.Helpers;
using LpjGuess.Core.Models;
using LpjGuess.Core.Models.Importer;
using LpjGuess.Core.Parsers;
using LpjGuess.Core.Services;
using Microsoft.Extensions.Logging;

namespace LpjGuess.Frontend.Classes;

/// <summary>
/// Data class which combines an instruction file, its parser, and output
/// file name resolver.
/// </summary>
public class SimulationReader
{
    /// <summary>
    /// The output file parser.
    /// </summary>
    private readonly ModelOutputParser outputParser;

    /// <summary>
    /// Collection of unknown output files.
    /// </summary>
    private readonly HashSet<string> unknownFiles = [];

    /// <summary>
    /// The instruction file.
    /// </summary>
    public InstructionFile InsFile { get; private init; }

    /// <summary>
    /// Output file type resolver.
    /// </summary>
    public OutputFileTypeResolver Resolver { get; private init; }

    /// <summary>
    /// Instruction file parser.
    /// </summary>
    public InstructionFileParser Parser { get; private init; }

    /// <summary>
    /// Helper for the instruction file.
    /// </summary>
    public InstructionFileHelper Helper { get; private init; }

    /// <summary>
    /// Gridlist parser.
    /// </summary>
    public GridlistParser Gridlist { get; private init; }

    /// <summary>
    /// Create a new <see cref="SimulationReader"/> instance.
    /// </summary>
    /// <param name="insFile">The instruction file.</param>
    public SimulationReader(InstructionFile insFile)
    {
        InsFile = insFile;

        // TODO: dependency injection. Don't create an OutputParser every time.
        var factory = new LoggerFactory();
        var logger = new Logger<OutputFileTypeResolver>(factory);
        var logger2 = new Logger<ModelOutputParser>(factory);
        var logger3 = new Logger<InstructionFileHelper>(factory);

        // TODO: proper async support.
        Parser = InstructionFileParser.FromFile(insFile.FileName);
        Helper = new InstructionFileHelper(Parser, logger3);

        string gridlist = Helper.GetGridlist();
        Gridlist = new GridlistParser(gridlist);

        Resolver = new OutputFileTypeResolver(logger);
        Resolver.BuildLookupTable(Parser);

        outputParser = new ModelOutputParser(logger2, Resolver);
    }

    /// <summary>
    /// Get all output files generated by this simulation.
    /// </summary>
    /// <returns>Collection of output files.</returns>
    public IEnumerable<OutputFile> GetOutputFiles()
    {
        string outputDirectory = Helper.GetOutputDirectory();
        IEnumerable<string> outputFiles = Directory.EnumerateFiles(outputDirectory, "*.out");
        var x = outputFiles.Select(CreateOutputFile).ToList();
        var files = x
                          .Where(file => file != null)
                          .Cast<OutputFile>()
                          .ToList();
        return files;
    }

    /// <summary>
    /// Create an output file object for file at the specified path.
    /// </summary>
    /// <param name="outputFile">Path to an output file.</param>
    /// <returns>The output file object.</returns>
    private OutputFile? CreateOutputFile(string outputFile)
    {
        string fileName = Path.GetFileName(outputFile);
        if (!Resolver.TryGetFileType(fileName, out string? fileType))
        {
            lock (unknownFiles)
            {
                if (!unknownFiles.Contains(outputFile))
                    Console.WriteLine($"Output file not recognised: {outputFile}");
                unknownFiles.Add(outputFile);
            }
            return null;
        }
        OutputFileMetadata metadata = OutputFileDefinitions.GetMetadata(fileType);
        return new OutputFile(metadata, outputFile);
    }

    /// <summary>
    /// Read a model output file.
    /// </summary>
    /// <param name="fileType">The output file *type* (e.g. "file_lai").</param>
    /// <param name="ct">The cancellation token.</param>
    /// <returns>The parsed output file.</returns>
    public Task<Quantity> ReadOutputFileTypeAsync(string fileType, CancellationToken ct)
    {
        string fileName = Resolver.GetFileName(fileType);

        string outputDirectory = Helper.GetOutputDirectory();
        string outputFile = Path.Combine(outputDirectory, fileName);
        return ReadOutputFileAsync(outputFile, ct);
    }

    /// <summary>
    /// Read a model output file.
    /// </summary>
    /// <param name="fileName">The output file name (e.g. "lai.out"). This must
    /// be absolute or relative to the current working directory.</param>
    /// <param name="ct">The cancellation token.</param>
    /// <returns>The parsed output file.</returns>
    public async Task<Quantity> ReadOutputFileAsync(string fileName, CancellationToken ct)
    {
        return await outputParser.ParseOutputFileAsync(fileName, ct);
    }

    /// <summary>
    /// Read the metadata from a model output file.
    /// </summary>
    /// <param name="fileType">The output file type (e.g. "file_lai").</param>
    /// <param name="ct">The cancellation token.</param>
    /// <returns>The metadata read from the file.</returns>
    public Task<IEnumerable<LayerMetadata>> ReadOutputFileMetadataAsync(string fileType, CancellationToken ct = default)
    {
        string fileName = Resolver.GetFileName(fileType);
        string outputDirectory = Helper.GetOutputDirectory();
        string outputFile = Path.Combine(outputDirectory, fileName);
        return outputParser.ParseOutputFileHeaderAsync(outputFile, ct);
    }
}
