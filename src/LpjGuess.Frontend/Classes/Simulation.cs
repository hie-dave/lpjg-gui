using Dave.Benchmarks.Core.Models;
using Dave.Benchmarks.Core.Models.Importer;
using Dave.Benchmarks.Core.Services;
using LpjGuess.Core.Models;
using LpjGuess.Runner.Extensions;
using LpjGuess.Runner.Models;
using LpjGuess.Runner.Parsers;
using Microsoft.Extensions.Logging;

namespace LpjGuess.Frontend.Classes;

/// <summary>
/// Data class which combines an instruction file, its parser, and output
/// file name resolver.
/// </summary>
public class Simulation
{
    /// <summary>
    /// The output file parser.
    /// </summary>
    private readonly ModelOutputParser outputParser;

    /// <summary>
    /// Path to the instruction file.
    /// </summary>
    public string FileName { get; private init; }

    /// <summary>
    /// Output file type resolver.
    /// </summary>
    public OutputFileTypeResolver Resolver { get; private init; }

    /// <summary>
    /// Instruction file parser.
    /// </summary>
    public InstructionFileParser InstructionFile { get; private init; }

    /// <summary>
    /// Create a new <see cref="Simulation"/> instance.
    /// </summary>
    /// <param name="fileName">Path to the instruction file.</param>
    public Simulation(string fileName)
    {
        FileName = fileName;

        // TODO: dependency injection. Don't create an OutputParser every time.
        var factory = new LoggerFactory();
        var logger = new Logger<OutputFileTypeResolver>(factory);
        var logger2 = new Logger<ModelOutputParser>(factory);

        // TODO: proper async support.
        InstructionFile = InstructionFileParser.FromFile(fileName);

        Resolver = new OutputFileTypeResolver(logger);
        Resolver.BuildLookupTable(InstructionFile);

        outputParser = new ModelOutputParser(logger2, Resolver);
    }

    /// <summary>
    /// Get all output files generated by this simulation.
    /// </summary>
    /// <returns>Collection of output files.</returns>
    public IEnumerable<OutputFile> GetOutputFiles()
    {
        string outputDirectory = InstructionFile.GetOutputDirectory();
        IEnumerable<string> outputFiles = Directory.EnumerateFiles(outputDirectory, "*.out");
        return outputFiles.Select(CreateOutputFile)
                          .Where(file => file != null)
                          .Cast<OutputFile>();
    }

    /// <summary>
    /// Create an output file object for file at the specified path.
    /// </summary>
    /// <param name="outputFile">Path to an output file.</param>
    /// <returns>The output file object.</returns>
    private OutputFile? CreateOutputFile(string outputFile)
    {
        try
        {
            string fileName = Path.GetFileName(outputFile);
            string fileType = Resolver.GetFileType(fileName);
            OutputFileMetadata metadata = OutputFileDefinitions.GetMetadata(fileType);
            return new OutputFile(metadata, outputFile);
        }
        catch (KeyNotFoundException)
        {
            // This will happen if this function is called for an output file
            // not defined in the instruction file. This occurs commonly, e.g.
            // when someone runs the model, disables one of the output files by
            // commenting it out in the instruction file, and then running the
            // model again. When this happens, we have no robust way of knowing
            // the output file type (though perhaps we could make some educated
            // guesses). Nonetheless, we don't really want to clutter up stderr
            // with repeated exceptions of this kind.
            return null;
        }
    }

    /// <summary>
    /// Read a model output file.
    /// </summary>
    /// <param name="fileType">The output file *type* (e.g. "file_lai").</param>
    /// <returns>The parsed output file.</returns>
    public Task<Quantity> ReadOutputFileTypeAsync(string fileType)
    {
        string fileName = Resolver.GetFileName(fileType);

        string outputDirectory = InstructionFile.GetOutputDirectory();
        string outputFile = Path.Combine(outputDirectory, fileName);
        return ReadOutputFileAsync(outputFile);
    }

    /// <summary>
    /// Read a model output file.
    /// </summary>
    /// <param name="fileName">The output file name (e.g. "lai.out"). This must
    /// be absolute or relative to the current working directory.</param>
    /// <returns>The parsed output file.</returns>
    public async Task<Quantity> ReadOutputFileAsync(string fileName)
    {
        return await outputParser.ParseOutputFileAsync(fileName);
    }

    /// <summary>
    /// Read the metadata from a model output file.
    /// </summary>
    /// <param name="fileType">The output file type (e.g. "file_lai").</param>
    /// <returns>The metadata read from the file.</returns>
    public Task<IEnumerable<LayerMetadata>> ReadOutputFileMetadataAsync(string fileType)
    {
        string fileName = Resolver.GetFileName(fileType);
        string outputDirectory = InstructionFile.GetOutputDirectory();
        string outputFile = Path.Combine(outputDirectory, fileName);
        return outputParser.ParseOutputFileHeaderAsync(outputFile);
    }
}
